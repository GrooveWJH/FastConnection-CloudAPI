(function () {
  const appConfig = window.APP_CONFIG || {};
  const MQTT_WS_PORT_OVERRIDE = appConfig.mqttWsPort;
  const MQTT_WS_PATH = typeof appConfig.mqttWsPath === "string" ? appConfig.mqttWsPath : "/mqtt";
  const WS_PATH = MQTT_WS_PATH.startsWith("/") ? MQTT_WS_PATH : `/${MQTT_WS_PATH}`;

  const DEFAULT_TCP_PORT = "1883";
  const DEFAULT_WS_PORT = MQTT_WS_PORT_OVERRIDE && MQTT_WS_PORT_OVERRIDE !== "" ? MQTT_WS_PORT_OVERRIDE : "8083";
  const PAGE_HOST = window.location.hostname || "127.0.0.1";

  function deriveWebsocketUrl(tcpUrl) {
    if (!tcpUrl) {
      return "";
    }
    const secure = /^ssl:\/\//i.test(tcpUrl) || /^mqtts:\/\//i.test(tcpUrl);
    const protocol = secure ? "wss" : "ws";
    const defaultPort = secure ? "8084" : DEFAULT_WS_PORT;
    const port = MQTT_WS_PORT_OVERRIDE && MQTT_WS_PORT_OVERRIDE !== "" ? MQTT_WS_PORT_OVERRIDE : defaultPort;
    const hostPort = tcpUrl.replace(/^[a-z]+:\/\//i, "").split("/")[0] || PAGE_HOST;
    const host = hostPort.split(":")[0] || PAGE_HOST;
    const resolvedPort = port || (secure ? "8084" : DEFAULT_WS_PORT);
    return `${protocol}://${host}:${resolvedPort}${WS_PATH}`;
  }

  function normalizeTcpUrl(value) {
    const trimmed = (value || "").trim();
    if (!trimmed) {
      return "";
    }
    if (/^[a-z]+:\/\//i.test(trimmed)) {
      return trimmed;
    }
    if (trimmed.includes(":")) {
      return `tcp://${trimmed}`;
    }
    return `tcp://${trimmed}:${DEFAULT_TCP_PORT}`;
  }

  function normalizeWsUrl(value, tcpUrl) {
    const trimmed = (value || "").trim();
    if (!trimmed) {
      return deriveWebsocketUrl(tcpUrl);
    }
    if (/^[a-z]+:\/\//i.test(trimmed)) {
      return trimmed;
    }
    if (trimmed.includes("/")) {
      return `ws://${trimmed}`;
    }
    if (trimmed.includes(":")) {
      return `ws://${trimmed}${WS_PATH}`;
    }
    return `ws://${trimmed}:${DEFAULT_WS_PORT}${WS_PATH}`;
  }

  const defaultTcpUrl = normalizeTcpUrl(appConfig.mqttTcpUrl || `tcp://${PAGE_HOST}:${DEFAULT_TCP_PORT}`) || `tcp://${PAGE_HOST}:${DEFAULT_TCP_PORT}`;
  const defaultWsUrl = normalizeWsUrl(appConfig.mqttWsUrl || "", defaultTcpUrl);
  const DEFAULT_USERNAME = appConfig.mqttUsername || "admin";
  const DEFAULT_PASSWORD = appConfig.mqttPassword || "public";

  const APP_ID = 171440;
  const LICENSE =
    "krC5HsEFLzVC8xkKM38JCcSxNEQvsQ/7IoiHEJRaulGiPQildia+n/+bF+SO21pk1JTS8CfaNS+fn8qt+17i3Y7uoqtBOOsdtLUQhqPMb0DVea0dmZ7oZhdP2CuQrQSn1bobS3pQ+MW2eEOq0XCcCkpo+HxAC1r5/33yEDxc6NE=";
  const APP_KEY = "b57ab1ee70f0a78e1797c592742e7d4";

  const logsContainer = document.getElementById("logs");
  const connectionInfo = document.getElementById("connection-info");
  const tcpInput = document.getElementById("mqtt-tcp");
  const wsInput = document.getElementById("mqtt-ws");
  const authModeInputs = Array.from(document.querySelectorAll('input[name="auth-mode"]'));
  const usernameInput = document.getElementById("mqtt-username");
  const passwordInput = document.getElementById("mqtt-password");
  const testButton = document.getElementById("test-button");

  let isConnected = false;
  let lastCredentials = null;

  tcpInput.value = defaultTcpUrl;
  wsInput.value = defaultWsUrl;
  wsInput.dataset.autofill = appConfig.mqttWsUrl ? "false" : "true";
  usernameInput.value = DEFAULT_USERNAME || "";
  passwordInput.value = DEFAULT_PASSWORD || "";
  const defaultAnonymous = !DEFAULT_USERNAME && !DEFAULT_PASSWORD;
  authModeInputs.forEach((input) => {
    input.checked = input.value === (defaultAnonymous ? "anonymous" : "credential");
  });
  lastCredentials = getSelectedCredentials();

  function getSelectedCredentials() {
    const mode = authModeInputs.find((input) => input.checked)?.value || "credential";
    const tcpUrl = normalizeTcpUrl(tcpInput.value) || defaultTcpUrl;
    const wsUrl = normalizeWsUrl(wsInput.value, tcpUrl);
    if (mode === "anonymous") {
      return { username: "", password: "", isAnonymous: true, tcpUrl, wsUrl };
    }
    return {
      username: usernameInput.value.trim(),
      password: passwordInput.value,
      isAnonymous: false,
      tcpUrl,
      wsUrl,
    };
  }

  function updateAuthModeUI() {
    const creds = getSelectedCredentials();
    usernameInput.disabled = creds.isAnonymous;
    passwordInput.disabled = creds.isAnonymous;
    usernameInput.closest("label").classList.toggle("disabled", creds.isAnonymous);
    passwordInput.closest("label").classList.toggle("disabled", creds.isAnonymous);
    updateConnectionInfo();
  }

  function updateConnectionInfo() {
    const creds = getSelectedCredentials();
    const statusClass = isConnected ? "status-connected" : "status-disconnected";
    const statusText = isConnected ? "已连接" : "未连接";
    const wsUrl = creds.wsUrl;
    const tcpUrl = creds.tcpUrl;
    const usernameDisplay = creds.isAnonymous ? "匿名连接" : creds.username || "(未填写)";
    const passwordDisplay = creds.isAnonymous ? "（匿名）" : creds.password ? "******" : "(未填写)";

    connectionInfo.innerHTML = `
      <div style="margin-bottom: 10px;">
        <strong>Cloud API MQTT 目标</strong>
        <span class="status-indicator ${statusClass}"></span>
        <span>${statusText}</span>
      </div>
      <div><strong>TCP 地址:</strong> ${tcpUrl}</div>
      <div><strong>WebSocket 地址:</strong> ${wsUrl}</div>
      <div><strong>账号:</strong> ${usernameDisplay}</div>
      <div><strong>密码:</strong> ${passwordDisplay}</div>
    `;
  }

  function log(message, type = "info") {
    const timestamp = new Date().toLocaleTimeString();
    const logItem = document.createElement("div");
    logItem.className = `log-item log-${type}`;
    logItem.textContent = `[${timestamp}] ${message}`;
    logsContainer.appendChild(logItem);
    logsContainer.scrollTop = logsContainer.scrollHeight;
  }

  function testMqttConnection(credentials) {
    const creds = credentials || getSelectedCredentials();
    if (!creds.isAnonymous && (!creds.username || !creds.password)) {
      log("账号或密码为空，无法测试连接。", "error");
      return;
    }

    try {
      const url = creds.wsUrl;
      const clientId = "dji_test_" + Math.random().toString(16).substr(2, 8);
      const options = {
        clientId,
        reconnectPeriod: 0,
        connectTimeout: 10000,
        clean: true,
      };
      if (!creds.isAnonymous) {
        options.username = creds.username;
        options.password = creds.password;
      }

      log(`⚙️ 正在测试 MQTT 连接 (clientId: ${clientId})`, "info");
      const tempClient = mqtt.connect(url, options);

      tempClient.on("connect", () => {
        log("MQTT 测试连接成功，立即断开。", "success");
        tempClient.end(true, () => {
          log("MQTT 测试连接已关闭", "info");
        });
      });

      tempClient.on("error", (error) => {
        log(`MQTT 测试连接错误 (clientId: ${clientId}): ${error.message}`, "error");
        tempClient.end(true);
      });

      tempClient.on("close", () => {
        // handled above
      });
    } catch (error) {
      log("MQTT 测试连接失败: " + error.message, "error");
    }
  }

  function reg_callback() {
    log("DJI Bridge 回调触发 🎉 参数：" + Array.from(arguments).join(", "), "success");
    isConnected = true;
    updateConnectionInfo();
  }

  function initPage() {
    updateConnectionInfo();
    log("页面初始化完成", "info");
    log(
      "Cloud API 许可证状态：" +
        (window.djiBridge ? window.djiBridge.platformIsVerified() : "未检测到 DJI RC Cloud API"),
      "info",
    );
  }

  document.getElementById("login-button").addEventListener("click", () => {
    log("=== 开始登录流程 ===", "info");
    const creds = getSelectedCredentials();
    lastCredentials = creds;

    if (!window.djiBridge) {
      log("未检测到 DJI RC Cloud API 环境，直接测试 MQTT 即可。", "error");
      return;
    }

    try {
      log("如需验证 MQTT 配置，可先使用“测试 MQTT”按钮。", "info");

      log("开始验证平台许可证...", "info");
      const token = window.djiBridge.platformVerifyLicense(APP_ID, APP_KEY, LICENSE);
      log("平台验证状态：" + window.djiBridge.platformIsVerified(), "info");

      const registerParams = JSON.stringify({
        host: creds.tcpUrl,
        connectCallback: "reg_callback",
        username: creds.username,
        password: creds.password,
      });

      log("加载 thing 组件：" + window.djiBridge.platformLoadComponent("thing", registerParams), "info");
      log("当前状态：" + window.djiBridge.thingGetConnectState(), "info");

      log(
        "开始连接 thing：" + window.djiBridge.thingConnect(creds.username, creds.password, "reg_callback"),
        "info",
      );
      log("Thing 连接状态：" + window.djiBridge.thingGetConnectState(), "info");
      isConnected = true;
      updateConnectionInfo();
    } catch (error) {
      log("DJI Bridge 操作错误: " + error.message, "error");
    }
  });

  document.getElementById("logout-button").addEventListener("click", () => {
    log("=== 开始断开流程 ===", "info");
    if (!window.djiBridge) {
      log("未检测到 DJI RC Cloud API 环境，跳过组件卸载。", "error");
      isConnected = false;
      updateConnectionInfo();
      return;
    }

    try {
      log("卸载组件：" + window.djiBridge.platformUnloadComponent("thing"), "info");
      if (window.djiBridge.thingDisconnect) {
        try {
          window.djiBridge.thingDisconnect();
        } catch (err) {
          // optional
        }
      }
      isConnected = false;
      updateConnectionInfo();
    } catch (error) {
      log("DJI Bridge 注销错误: " + error.message, "error");
    }
  });

  document.getElementById("status-button").addEventListener("click", () => {
    log("=== 状态报告 ===", "info");
    log("MQTT 连接状态：" + (isConnected ? "已连接" : "未连接"), "info");

    if (!window.djiBridge) {
      log("未检测到 DJI RC Cloud API 环境，无法查询设备状态。", "error");
      isConnected = false;
      updateConnectionInfo();
      return;
    }

    try {
      log("组件加载状态：" + window.djiBridge.platformIsComponentLoaded("thing"), "info");
      log("Thing 状态：" + window.djiBridge.thingGetConnectState(), "info");
      log("平台验证状态：" + window.djiBridge.platformIsVerified(), "info");
      const thingState = window.djiBridge.thingGetConnectState();
      isConnected = thingState === true || thingState === 1;
      updateConnectionInfo();
    } catch (error) {
      log("DJI Bridge 状态查询错误: " + error.message, "error");
    }
  });

  window.addEventListener("load", initPage);
  window.reg_callback = reg_callback;

  authModeInputs.forEach((input) =>
    input.addEventListener("change", () => {
      updateAuthModeUI();
    }),
  );
  usernameInput.addEventListener("input", () => {
    updateConnectionInfo();
  });
  passwordInput.addEventListener("input", () => {
    updateConnectionInfo();
  });
  tcpInput.addEventListener("input", () => {
    if (wsInput.dataset.autofill !== "false") {
      const normalizedTcp = normalizeTcpUrl(tcpInput.value) || defaultTcpUrl;
      wsInput.value = deriveWebsocketUrl(normalizedTcp);
    }
    updateConnectionInfo();
  });
  wsInput.addEventListener("input", () => {
    wsInput.dataset.autofill = wsInput.value.trim() === "" ? "true" : "false";
    updateConnectionInfo();
  });
  updateAuthModeUI();

  testButton.addEventListener("click", () => {
    const creds = getSelectedCredentials();
    lastCredentials = creds;
    testMqttConnection(creds);
  });
})();
